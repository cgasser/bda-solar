R> head(allValues,7)
head(allValues,7)
##
allValues <- merge(
x=data.frame(Date=allDates),
y=values,
all.x=TRUE, all.y=TRUE)
head(allValues,7)
##
df <- melt(data.frame(allDates, values))
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, 0, 0, -0.3486378)
##
df <- melt(data.frame(allDates, values))
allValues <- merge(
x=data.frame(Date=allDates),
y=values,
all.x=TRUE)
head(allValues,7)
cond <-c(1,2,3)
rating <-c(100,200,300)
df <- data.frame(cond, rating)
df
allDates
values
##
df <- melt(data.frame(allDates, values))
##
df <- data.frame(allDates, values)
df
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, NULL, NULL, -0.3486378)
values
##
df <- data.frame(allDates, values)
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, n/a, n/a, -0.3486378)
values
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, n/a, n/a, -0.3486378)
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, NA, NA, -0.3486378)
values
##
df <- data.frame(allDates, values)
df
df <- melt(data.frame(allDates, values))
allValues <- merge(
x=data.frame(Date=allDates),
y=values,
all.x=TRUE)
head(allValues,7)
##
zooValues <- zoo(allValues$Value,allValues$Date)
colnames(df) <- c("Date", "Value")
df
##
zooValues <- zoo(allValues$Value,allValues$Date)
head(zooValues,7)
2010-01-05 2010-01-06 2010-01-07 2010-01-08 2010-01-09 2010-01-10 2010-01-11
library(zoo)
library(lubridate)
allDates <- seq.Date(as.Date("2010-01-05"), as.Date("2010-01-11"), "day")
values <- c(-0.6041787, 0.2274668, -1.2751761, -0.8696818, NA, NA, -0.3486378)
##
df <- data.frame(allDates, values)
colnames(df) <- c("Date", "Value")
df
##
zooValues <- zoo(allValues$Value,allValues$Date)
head(zooValues,7)
zooValues <- zoo(df$Value, df$Date)
head(zooValues)
approxValues <- na.approx(zooValues)
head(approxValues)
head(zooValues, 7)
approxValues <- na.approx(zooValues)
head(approxValues, 7)
plot(approxValues)
plot(zooValues)
plot(approxValues)
##
t0 <- "2010-01-04"
Dates <- as.Date(ymd(t0))+1:120
weekDays <- Dates[!(weekdays(Dates) %in% c("Saturday","Sunday"))]
##
set.seed(123)
values <- data.frame(Date=weekDays,Value=rnorm(length(weekDays)))
values
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
library(lubridate)
library(tseries)
library(zoo)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# select panel
currentAttribute <- dt$power1
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, currentAttribute)
colnames(dfRaw) <- c("time", "power")
# filter outliers
df <- dfRaw[dfRaw$power < 3,]
colnames(df) <- c("time", "power")
# filter for complete months
startDate <- ymd_hms("2010-12-01 00:00:00")
endDate <- ymd_hms("2017-10-01 00:00:00")
df <- subset(df, df$time >= startDate)
df <- subset(df, df$time < endDate)
# add a date column
df$date <- as.Date(df$time)
df$month <- as.Date(format(df$time, "%Y-%m-01"), format = "%Y-%m-%d")
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
dfMonths <- aggregate(list(energy = df$power), by = list(date = df$month), FUN = sum)
plot(dfMonths)
# visualize the energy per day along time
plot(dfDays)
# Additive Time Series
# definition ts: data which has been sampled at equispaced points in time
# per day: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerDay <- ts(dfDays$energy, start = c(2010, 12), end = c(2015, 01), frequency = 365)
time(tsEnergyPerDay)
decomposeEnergy <- decompose(tsEnergyPerDay, "additive")
# per month: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerMonth <- ts(dfMonths$energy, start = c(2010, 12), frequency = 12)
time(tsEnergyPerMonth)
decomposeEnergy <- decompose(tsEnergyPerMonth, "additive")
zooValues <- zoo(dfDays$energy, dfDays$date)
head(zooValues, 7)
plot(zooValues)
approxValues <- na.approx(zooValues)
head(approxValues, 7)
plot(approxValues)
zooValues <- zoo(dfDays$energy, dfDays$date)
head(zooValues, 7)
plot(zooValues)
approxValues <- na.approx(zooValues)
head(approxValues, 7)
plot(approxValues)
View(dfDays)
class(df$date)
target <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
View(target)
merge(dfDays, missingDates, all.y = TRUE)
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
merge(dfDays, missingDates, all.y = TRUE)
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
merge(dfDays, missingDates, all.y = TRUE)
View(dfDays)
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
library(lubridate)
library(tseries)
library(zoo)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# select panel
currentAttribute <- dt$power1
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, currentAttribute)
colnames(dfRaw) <- c("time", "power")
# filter outliers
df <- dfRaw[dfRaw$power < 3,]
colnames(df) <- c("time", "power")
# filter for complete months
startDate <- ymd_hms("2010-12-01 00:00:00")
endDate <- ymd_hms("2017-10-01 00:00:00")
df <- subset(df, df$time >= startDate)
df <- subset(df, df$time < endDate)
# filter out zero days
dfDays <- dfDays[dfDays$energy > 0,]
dfMonths <- dfMonths[dfMonths$energy > 0,]
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
library(lubridate)
library(tseries)
library(zoo)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# select panel
currentAttribute <- dt$power1
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, currentAttribute)
colnames(dfRaw) <- c("time", "power")
# filter outliers
df <- dfRaw[dfRaw$power < 3,]
colnames(df) <- c("time", "power")
# filter for complete months
startDate <- ymd_hms("2010-12-01 00:00:00")
endDate <- ymd_hms("2017-10-01 00:00:00")
df <- subset(df, df$time >= startDate)
df <- subset(df, df$time < endDate)
# add a date column
df$date <- as.Date(df$time)
df$month <- as.Date(format(df$time, "%Y-%m-01"), format = "%Y-%m-%d")
class(df$date)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
dfMonths <- aggregate(list(energy = df$power), by = list(date = df$month), FUN = sum)
# filter out zero days
dfDays <- dfDays[dfDays$energy > 0,]
dfMonths <- dfMonths[dfMonths$energy > 0,]
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
merge(dfDays, missingDates, all.y = TRUE)
dfDays <- merge(dfDays, missingDates, all.y = TRUE)
View(dfDays)
dfNew <- rbind(dfDays, missingDates)
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
View(missingDates)
View(missingDates)
dfNew <- rbind(dfDays, missingDates, all.y = TRUE)
View(missingDates)
View(missingDates)
View(dfDays)
View(dfDays)
# add a date column
missingDates$energy <- NA
View(missingDates)
View(missingDates)
dfNew <- rbind(dfDays, missingDates)
View(dfNew)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
dfMonths <- aggregate(list(energy = df$power), by = list(date = df$month), FUN = sum)
# filter out zero days
dfDays <- dfDays[dfDays$energy > 0,]
dfMonths <- dfMonths[dfMonths$energy > 0,]
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
# add a date column
missingDates$energy <- NA
# concatenate data with missing dates containing NA as energy value
dfNew <- rbind(dfDays, missingDates)
dfFilledUp
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
# concatenate data with missing dates containing NA as energy value
dfFilledUp <- rbind(dfDays, missingDates)
# concatenate data with missing dates containing NA as energy value
dfFilledUp <- rbind(dfDays, missingDates)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
head(zooValues, 7)
plot(zooValues)
approxValues <- na.approx(zooValues)
head(approxValues, 7)
plot(approxValues)
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
View(dfFilledUp)
# order by date
dfFilledUp <- dfFilledUp[order(dfFilledUp$date),]
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
View(dfDays)
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
library(lubridate)
library(tseries)
library(zoo)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# select panel
currentAttribute <- dt$power1
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, currentAttribute)
colnames(dfRaw) <- c("time", "power")
# filter outliers
df <- dfRaw[dfRaw$power < 3,]
colnames(df) <- c("time", "power")
# filter for complete months
startDate <- ymd_hms("2010-12-01 00:00:00")
endDate <- ymd_hms("2017-10-01 00:00:00")
df <- subset(df, df$time >= startDate)
df <- subset(df, df$time < endDate)
# add a date column
df$date <- as.Date(df$time)
df$month <- as.Date(format(df$time, "%Y-%m-01"), format = "%Y-%m-%d")
class(df$date)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
dfMonths <- aggregate(list(energy = df$power), by = list(date = df$month), FUN = sum)
# filter out zero days
dfDays <- dfDays[dfDays$energy > 0,]
dfMonths <- dfMonths[dfMonths$energy > 0,]
# visualize the energy per day along time
plot(dfDays)
plot(dfMonths)
# Additive Time Series
# definition ts: data which has been sampled at equispaced points in time
# per day: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerDay <- ts(dfDays$energy, start = c(2010, 12), end = c(2015, 01), frequency = 365)
time(tsEnergyPerDay)
decomposeEnergy <- decompose(tsEnergyPerDay, "additive")
time(tsEnergyPerMonth)
# per month: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerMonth <- ts(dfMonths$energy, start = c(2010, 12), frequency = 12)
plot(tsEnergyPerMonth)
plot(tsEnergyPerDay)
decomposeEnergy <- decompose(tsEnergyPerMonth, "additive")
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
library(lubridate)
library(tseries)
library(zoo)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# select panel
currentAttribute <- dt$power1
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, currentAttribute)
colnames(dfRaw) <- c("time", "power")
# filter outliers
df <- dfRaw[dfRaw$power < 3,]
colnames(df) <- c("time", "power")
# filter for complete months
startDate <- ymd_hms("2010-12-01 00:00:00")
endDate <- ymd_hms("2017-10-01 00:00:00")
df <- subset(df, df$time >= startDate)
df <- subset(df, df$time < endDate)
# add a date column
df$date <- as.Date(df$time)
df$month <- as.Date(format(df$time, "%Y-%m-01"), format = "%Y-%m-%d")
class(df$date)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy = df$power), by = list(date = df$date), FUN = sum)
dfMonths <- aggregate(list(energy = df$power), by = list(date = df$month), FUN = sum)
# filter out zero days
dfDays <- dfDays[dfDays$energy > 0,]
dfMonths <- dfMonths[dfMonths$energy > 0,]
# Additive Time Series
# definition ts: data which has been sampled at equispaced points in time
# per day: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerDay <- ts(dfDays$energy, start = c(2010, 12), end = c(2015, 01), frequency = 365)
time(tsEnergyPerDay)
plot(tsEnergyPerDay)
decomposeEnergy <- decompose(tsEnergyPerDay, "additive")
# per month: use a frequency of 365 since the data contains one sample per day and is expected to repeat every year
tsEnergyPerMonth <- ts(dfMonths$energy, start = c(2010, 12), frequency = 12)
time(tsEnergyPerMonth)
plot(tsEnergyPerMonth)
decomposeEnergy <- decompose(tsEnergyPerMonth, "additive")
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-02-28"), by = "day"))
# add a date column
missingDates$energy <- NA
length(dfDays)
View(dfDays)
nrow(dfDays)
nrow(missingDates)
nrow(dfDays) + nrow(missingDates)
# concatenate data with missing dates containing NA as energy value
dfFilledUp <- rbind(dfDays, missingDates)
# order by date
dfFilledUp <- dfFilledUp[order(dfFilledUp$date),]
nrow(dfFilledUp)
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
locfValues <- na.locf(zooValues)
plot(locfValues)
stuctTsValues <- na.StructTS(zooValues)
plot(stuctTsValues)
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
locfValues <- na.locf(zooValues)
plot(locfValues)
stuctTsValues <- na.StructTS(zooValues)
stuctTsValues <- na.StructTS(zooValues)
View(dfFilledUp)
View(dfFilledUp)
missingDates <- data.frame(date = seq(from = as.Date("2015-10-11"), to = as.Date("2016-03-01"), by = "day"))
# add a date column
missingDates$energy <- NA
# concatenate data with missing dates containing NA as energy value
dfFilledUp <- rbind(dfDays, missingDates)
# order by date
dfFilledUp <- dfFilledUp[order(dfFilledUp$date),]
nrow(dfDays) + nrow(missingDates)
nrow(dfFilledUp)
testZoo <- zoo(dfDays$energy, dfDays$date)
plot(testZoo)
zooValues <- zoo(dfFilledUp$energy, dfFilledUp$date)
plot(zooValues)
approxValues <- na.approx(zooValues)
plot(approxValues)
locfValues <- na.locf(zooValues)
plot(locfValues)
stuctTsValues <- na.StructTS(zooValues)
tsZooValues <- as.ts(zooValues)
stuctTsValues <- na.StructTS(zooValues)
stuctTsValues <- na.StructTS(tsZooValues)
plot(stuctTsValues)
stuctTsValues
tsZooValues <- as.ts(zooValues)
stuctTsValues <- na.StructTS(tsZooValues)
plot(stuctTsValues)
stuctTsValues <- na.StructTS(tsZooValues)
splineValues <- na.spline(zooValues)
plot(splineValues)
locfValues <- na.locf(zooValues)
plot(locfValues)
locfValues <- na.locf(zooValues)
plot(locfValues)
