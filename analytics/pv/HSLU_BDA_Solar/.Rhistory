# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfClean$date <- as.Date(dfClean$time)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfClean$date <- 888
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfClean$date <- as.Date(dfClean$time)
dfEnergyPerDay <- aggregate(dfClean$power1, by=list(day=dfClean$date), FUN = sum)
dfClean$energy1 <- aggregate(dfClean$power1, by=list(day=dfClean$date), FUN = sum)
dt <- fread("data/birchli.csv")
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/pfadibaar.csv")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, dt$power1, dt$power2)
colnames(dfRaw) <- c("time", "power1", "power2")
# order by timestamp
dfRaw <- dfRaw[order(dfRaw$time),]
#
df <- df[dfRaw$power1 < 3 & dfRaw$power2 < 3,]
dfRaw
View(dt)
View(dfRaw)
View(dfRaw)
# order by timestamp
dfRaw <- dfRaw[order(dfRaw$time),]
# filter outliers
df <- dfRaw[dfRaw$power1 < 3 & dfRaw$power2 < 3,]
View(df)
View(df)
plot_ly(data = df, x=~time, y=~power2, type = "scatter", mode = "lines+markers", line=list(color="green"))
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfClean$date <- as.Date(dfClean$time)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
df$date <- as.Date(df$time)
dfDays <- df
View(dfDays)
View(dfDays)
dfDays$energy1 <- aggregate(df$power1, by=list(day=df$date), FUN = sum)
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
class(dt$timestampPosix)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
# attribute POWER1, POWER2
class(dt$power1)
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, dt$power1, dt$power2)
class(dt$power2)
# filter outliers
df <- dfRaw[dfRaw$power1 < 3 & dfRaw$power2 < 3,]
colnames(dfRaw) <- c("time", "power1", "power2")
# order by timestamp
dfRaw <- dfRaw[order(dfRaw$time),]
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
df$date <- as.Date(df$time)
class(dt$timestampPosix)
View(dfRaw)
View(dfRaw)
View(df)
View(df)
colnames(df) <- c("time", "power1", "power2")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
View(dt)
View(dt)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, dt$power1, dt$power2)
View(dfRaw)
View(dfRaw)
dfRaw
colnames(dfRaw) <- c("time", "power1", "power2")
# order by timestamp
dfRaw <- dfRaw[order(dfRaw$time),]
# filter outliers
df <- dfRaw[dfRaw$power1 < 3 & dfRaw$power2 < 3,]
colnames(df) <- c("time", "power1", "power2")
View(df)
View(df)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
df$date <- as.Date(df$time)
dfDays$energy1 <- aggregate(df$power1, by=list(day=df$date), FUN = sum)
tmp <- aggregate(df$power1, by=list(day=df$date), FUN = sum)
View(tmp)
View(tmp)
tmp <- aggregate(energy1=df$power1, by=list(date=df$date), FUN = sum)
tmp <- aggregate(df$power1, by=list(date=df$date), FUN = sum)
dfDays <- aggregate(df$power1, by=list(date=df$date), FUN = sum)
View(dfDays)
View(dfDays)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(df$power1, by=list(df$date), FUN = sum)
dfDays <- aggregate(list(df$power1, df$power2), by=list(date=df$date), FUN = sum)
dfDays <- aggregate(list(energy1=df$power1, df$power2), by=list(date=df$date), FUN = sum)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy1 = df$power1, energy2 = df$power2), by = list(date = df$date), FUN = sum)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy1 = df$power1, energy2 = df$power2), by = list(date = df$date), FUN = sum)
View(dfDays)
View(dfDays)
plot(dfDays)
plot(dfDays)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergy <- ts(dfDays, frequency = 365)
View(tsEnergy)
View(tsEnergy)
decomposeEnergy <- decompose(tsEnergy, "additive")
View(decomposeEnergy)
View(decomposeEnergy)
decomposeEnergy
plot(decomposeEnergy)
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
timestampPosix
class(dt$timestampPosix)
# order by timestamp
dt[order(dt$timestampPosix),]
View(dt)
View(dt)
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
dt <- fread("data/birchli.csv")
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/pfadibaar.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER
class(dt$cur_yield_watt)
# create a dataframe
df <- data.frame(dt$timestampPosix, dt$cur_yield_watt)
colnames(df) <- c("time", "power")
df <- df[order(df$time),]
# Visualize the time series
plot_ly(data = df, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="darkred"))
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
View(dt)
View(dt)
# order by timestamp
dt[order(dt$timestampPosix),]
# attribute POWER1, POWER2
class(dt$power1)
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
View(dt)
View(dt)
plot_ly(data = dt, x=~timestampPosix, y=~power1, type = "scatter", mode = "lines+markers", line=list(color="darkgreen"))
# create a dataframe
dfRaw <- data.frame(dt$timestampPosix, dt$power1, dt$power2)
colnames(dfRaw) <- c("time", "power1", "power2")
# filter outliers
df <- dfRaw[dfRaw$power1 < 3 & dfRaw$power2 < 3,]
colnames(df) <- c("time", "power1", "power2")
# Visualize the time series
plot_ly(data = df, x=~time, y=~power1, type = "scatter", mode = "lines+markers", line=list(color="darkgreen"))
dt <- fread("data/pfadibaar.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER
class(dt$cur_yield_watt)
# create a dataframe
df <- data.frame(dt$timestampPosix, dt$cur_yield_watt)
colnames(df) <- c("time", "power")
# Visualize the time series
plot_ly(data = df, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="darkred"))
dt <- dt[order(dt$timestampPosix),]
# order by timestamp
dt <- dt[order(dt$timestampPosix),]
# attribute POWER
class(dt$cur_yield_watt)
# create a dataframe
df <- data.frame(dt$timestampPosix, dt$cur_yield_watt)
colnames(df) <- c("time", "power")
# Visualize the time series
plot_ly(data = df, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="darkred"))
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/birchli.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# attribute POWER1, POWER2
class(dt$power1)
class(dt$power2)
# create a dataframe per series
dfRaw1 <- data.frame(dt$timestampPosix, dt$power1)
colnames(dfRaw) <- c("time", "power")
View(dfRaw1)
View(dfRaw1)
dfRaw1
colnames(dfRaw1) <- c("time", "power")
# create a dataframe per series
dfRaw1 <- data.frame(dt$timestampPosix, dt$power1)
dfRaw2 <- data.frame(dt$timestampPosix, dt$power2)
colnames(dfRaw1) <- c("time", "power")
colnames(dfRaw2) <- c("time", "power")
View(dfRaw2)
View(dfRaw2)
# filter outliers
df1 <- dfRaw[dfRaw$power1 < 3,]
df2 <- dfRaw[dfRaw$power2 < 3,]
colnames(df1) <- c("time", "power")
colnames(df2) <- c("time", "power")
# filter outliers
df1 <- dfRaw1[dfRaw1$power < 3,]
df2 <- dfRaw2[dfRaw2$power < 3,]
colnames(df1) <- c("time", "power")
colnames(df2) <- c("time", "power")
View(df2)
View(df2)
# Visualize the time series
plot_ly(data = df1, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="darkgreen"))
plot_ly(data = df2, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="green"))
# add a date column
df1$date <- as.Date(df1$time)
df2$date <- as.Date(df2$time)
View(df2)
View(df2)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays <- aggregate(list(energy1 = df1$power), by = list(date = df1$date), FUN = sum)
View(dfDays)
View(dfDays)
# sum up the 10-min power values per day to obtain a proxy value for the energy produced
dfDays1 <- aggregate(list(energy = df1$power), by = list(date = df1$date), FUN = sum)
dfDays2 <- aggregate(list(energy = df2$power), by = list(date = df2$date), FUN = sum)
plot(dfDays2)
plot(dfDays1)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergy <- ts(dfDays1, frequency = 365)
View(tsEnergy)
View(tsEnergy)
decomposeEnergy <- decompose(tsEnergy, "additive")
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergy <- ts(dfDays1, frequency = 2)
decomposeEnergy <- decompose(tsEnergy, "additive")
plot(decomposeEnergy)
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
stlEnergy = stl(tsEnergy, "periodic")
View(tsEnergy)
View(tsEnergy)
# Detect the trend in an additive time series using the "centered moving average"
# using a moving average window of 4 (quarterly data)
# install.packages("forecast")
library(forecast)
trend_beer = ma(timeserie_beer, order = 4, centre = T)
plot(as.ts(timeserie_beer))
# install.package(data.table)
library(data.table)
# install.package(xts)
library(xts)
# install.package(ggplot2)
library(ggplot2)
# install.package(plotly)
library(plotly)
# Set the time zone at the system level
Sys.setenv(TZ="Europe/Zurich")
dt <- fread("data/tweets_barcelona_082017.csv")
# The temporal data in dt is a string! Check:
class(dt$createdAt)
# Transform timestamp from character to POSIXct
dt$createdAt <- as.POSIXct(dt$createdAt,format="%Y-%m-%dT%H:%M:%SZ")
class(dt$createdAt)
# Aggregate irregular time series to regular
dt$obs <- 1
x.xts <- xts(dt$obs,dt$createdAt)
aligned.xts <- align.time(x.xts, n=3600)
agg.xts <- period.apply(aligned.xts, endpoints(aligned.xts, 'hours', 1), sum)
empty.xts <- xts(NULL,seq(start(aligned.xts),end(aligned.xts), by=3600))
out.df <- fortify(out)
colnames(out.df) <- c("time", "obs")
out <- merge(empty.xts, agg.xts)
out.df[is.na(out.df)] <- 0
# Visualize the time series
plot_ly(out.df, x=~time, y=~obs, type = "scatter", mode = 'lines')
# Example of an additive time series
# install.packages("fpp")
library(fpp)
data(ausbeer) # data are part of the package
timeserie_beer = tail(head(ausbeer, 17*4+2),17*4-4)
plot(as.ts(timeserie_beer))
# Example of a multiplicative time series
# install.packages("Ecdat")
library(Ecdat)
timeserie_air = AirPassengers
plot(as.ts(timeserie_air))
data(AirPassengers)
# Detect the trend in an additive time series using the "centered moving average"
# using a moving average window of 4 (quarterly data)
# install.packages("forecast")
library(forecast)
trend_beer = ma(timeserie_beer, order = 4, centre = T)
plot(as.ts(timeserie_beer))
lines(trend_beer)
plot(as.ts(trend_beer))
# Detect the trend in a multiplicative time series using the "centered moving average"
# Using a moving average window of 12 (monthly data)
trend_air = ma(timeserie_air, order = 12, centre = T)
plot(as.ts(timeserie_air))
plot(as.ts(trend_air))
# Detrending the time additive series
detrend_beer = timeserie_beer - trend_beer
lines(trend_air)
plot(as.ts(detrend_beer))
# Detrending the multiplicative time series
detrend_air = timeserie_air / trend_air
plot(as.ts(detrend_air))
# Compute average seasonality in additive time series
m_beer = t(matrix(data = detrend_beer, nrow = 4))
seasonal_beer = colMeans(m_beer, na.rm = T)
plot(as.ts(rep(seasonal_beer,16)))
# Compute average seasonality in multiplicative time series
m_air = t(matrix(data = detrend_air, nrow = 12))
seasonal_air = colMeans(m_air, na.rm = T)
plot(as.ts(rep(seasonal_air,12)))
# Extract the random noise left:
# Additive time series: "random = time series - seasonal - trend"
random_beer = timeserie_beer - trend_beer - seasonal_beer
plot(as.ts(random_beer))
# Extract the random noise left:
# Multiplicative time series: "random = time series / (seasonal * trend)"
random_air = timeserie_air / (trend_air * seasonal_air)
plot(as.ts(random_air))
# Reconstruct the original signal:
# Additive time series
recomposed_beer = trend_beer+seasonal_beer+random_beer
plot(as.ts(recomposed_beer))
# Reconstruct the original signal:
# Multiplicative time series
recomposed_air = trend_air*seasonal_air*random_air
plot(as.ts(recomposed_air))
###################################################
# The decompose()-function (all in one function!!!)
# Additive
ts_beer = ts(timeserie_beer, frequency = 4)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergy <- ts(dfDays1, frequency = 2)
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
stlEnergy = stl(tsEnergy, "periodic")
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
arrayEnergy = df(tsEnergy$energy)
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
arrayEnergy = df(tsEnergy)
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
arrayEnergy = df(tsEnergy, tsEnergy$energy)
# Using the STL( ) function (STL = Seasonal and Trend decomposition using Loess):
# Additive
arrayEnergy = tsEnergy$energy
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergy <- ts(dfDays1, frequency = 24 * 6)
decomposeEnergy <- decompose(tsEnergy, "additive")
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
decomposeEnergy <- decompose(tsEnergy, "multiplicative")
plot(decomposeEnergy)
decomposeEnergy <- decompose(tsEnergy, "additive")
plot(as.ts(decomposeEnergy$seasonal))
plot(as.ts(decomposeEnergy$trend))
plot(as.ts(decomposeEnergy$random))
plot(decomposeEnergy)
View(dfDays1)
View(dfDays1)
View(dfDays2)
View(dfDays2)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergyPerDay <- ts(dfDays1, frequency = 365)
decomposeEnergy <- decompose(tsEnergyPerDay, "additive")
plot(decomposeEnergy)
###################################################
# The decompose()-function (all in one function!!!)
# Additive
tsEnergyPerDay1 <- ts(dfDays1, frequency = 365)
decomposeEnergy1 <- decompose(tsEnergyPerDay1, "additive")
plot(as.ts(decomposeEnergy1$seasonal))
plot(as.ts(decomposeEnergy1$trend))
plot(as.ts(decomposeEnergy1$random))
plot(decomposeEnergy1)
dt <- fread("data/pfadibaar.csv")
# attribute TIMESTAMP
# The temporal data in dt is an integer. Check:
class(dt$timestamp)
# Transform timestamp from character to POSIXct
# https://stackoverflow.com/questions/27408131/convert-unix-timestamp-into-datetime-in-r
dt$timestampPosix <- as.POSIXct(as.numeric(as.character(dt$timestamp)), origin='1970-01-01', tz='GMT')
class(dt$timestampPosix)
# order by timestamp
dt <- dt[order(dt$timestampPosix),]
# attribute POWER
class(dt$cur_yield_watt)
# create a dataframe
df <- data.frame(dt$timestampPosix, dt$cur_yield_watt)
colnames(df) <- c("time", "power")
# Visualize the time series
plot_ly(data = df, x=~time, y=~power, type = "scatter", mode = "lines+markers", line=list(color="darkred"))
